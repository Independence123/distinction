<a href="http://blog.csdn.net/feitianxuxue/article/details/9275979">原文链接</a>

# distinction
homework 2
浅拷贝，即在定义一个类A，使用类似A obj;  A obj1(obj);或者A obj1 = obj; 时候，由于没有自定义拷贝构造函数，C++编译器自动会产生一个默认的拷贝构造函数。这个默认的拷贝构造函数采用的是“位拷贝”（浅拷贝），而非“值拷贝”（深拷贝）的方式，如果类中含有指针变量，默认的拷贝构造函数必定出错。
用一句简单的话来说就是浅拷贝，只是对指针的拷贝，拷贝后两个指针指向同一个内存空间，深拷贝不但对指针进行拷贝，而且对指针指向的内容进行拷贝，经深拷贝后的指针是指向两个不同地址的指针。
假如有一个成员变量的指针，char *m_data;
其一，浅拷贝只是拷贝了指针，使得两个指针指向同一个地址，这样在对象块结束，调用函数析构的时，会造成同一份资源析构2次，即delete同一块内存2次，造成程序崩溃。
其二，浅拷贝使得obj.m_data和obj1.m_data指向同一块内存，任何一方的变动都会影响到另一方。
其三，在释放内存的时候，会造成obj1.m_data原有的内存没有被释放（这句话，刚开始我不太理解，如果没有走自定义的拷贝构造函数，申请内存空间，A obj1(obj);也不走默认构造函数，走的是默认的拷贝构造函数，何来分配空间直说，更不会造成obj1.m_data原有的内存没有被释放，这里刚开始我一直有疑问），造成内存泄露。
事实是这样的，当delete obj.m_data, obj.m_data内存被释放后，由于之前obj.m_data和obj1.m_data指向的是同一个内存空间，obj1.m_data所指的空间不能在被利用了，delete obj1.m_data也不会成功，一致已经无法操作该空间，所以导致内存泄露。
深拷贝采用了在堆内存中申请新的空间来存储数据，这样每个可以避免指针悬挂。
    下面来看看类string的拷贝构造函数
[cpp] view plain copy
　　class String  
　　{  
　　    public:  
　　        String(const String &other);    //拷贝构造函数  
            private:  
　　        char *m_data;   //用于保存字符串  
　　};    
　　  
　　String(const String &other)  
　　{     
　　    int length = strlen(other.m_data);  
　　    m_data = new char[length + 1];  
　　    strcpy(m_data, other.m_data);  
}   

 可以看到在拷贝构造函数中为成员变量申请了新的内存空间，这就使得两个对象的成员变量不指向同一个内存空间，除非你的确需要这样做，用于实现一些其他的用途。
  浅拷贝：也就是在对象复制时，只是对对象中的数据成员进行简单的赋值，如果对象中存在动态成员，即指针，浅拷贝就会出现问题，下面代码：
[cpp] view plain copy
#include <stdio.h>  
  
class A  
{  
    public:  
        A()      // 构造函数，p指向堆中分配的一空间  
        {  
            m_data = new char(100);  
            printf("默认构造函数\n");  
        }  
        运行结果：
*** glibc detected *** ./simple: double free or corruption (fasttop): 0x000000000c62a010 ***
分析：由于没有拷贝构造函数，走编译器默认的拷贝构造函数，A b(a); 进行对象析构时，会造成释放同一内存空间2次，导致内存泄露。
 深拷贝：对于深拷贝，针对成员变量存在指针的情况，不仅仅是简单的指针赋值，而是重新分配内存空间，如下：
[cpp] view plain copy
#include <stdio.h>  
#include <string>  
  
class A  
{  
    public:  
        A()      // 构造函数，p指向堆中分配的一空间  
        {  
            m_pdata = new char(100);  
            printf("默认构造函数\n");  
        }  
  
        A(const A& r)  
        {  
            m_pdata = new char(100);    // 为新对象重新动态分配空间  
            memcpy(m_pdata, r.m_pdata, strlen(r.m_pdata));  
            printf("copy构造函数\n");  
        }  
  
        ~A()     // 析构函数，释放动态分配的空间  
        {  
            if(m_pdata != NULL)  
            {  
                delete m_pdata;  
                printf("析构函数\n");  
            }  
        }  
  
    private:  
        char *m_pdata;     // 一指针成员  
};  
  
int main()  
{  
    A a;  
    A b(a);   // 复制对象  
    return 0;  
}  

        ~A()     // 析构函数，释放动态分配的空间  
        {  
            if(m_data != NULL)  
            {  
                delete m_data;  
                m_data = NULL;  
                printf("析构函数\n");  
            }  
        }  
    private:  
        char *m_data;     // 一指针成员  
};  
  
int main()  
{  
    A a;  
    A b(a);   // 复制对象  
    return 0;  
}  
1. 有时候为了防止默认拷贝发生，可以声明一个私有的拷贝构造函数（不用写代码），这样的话，如果试图调用 A  b(a); 就调用了私有的拷贝构造函数，编译器会报错，这也是一种偷懒的做法。
2.  一个类中可以存在多个拷贝构造函数，例如：
[cpp] view plain copy
Calss A  
{  
Public:  
X(const X&);//const拷贝构造  
X(X &);//非const拷贝构造  
X(X& , int  iData);  
}  
